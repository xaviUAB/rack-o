<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rack-O Multijugador v 1.2.</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclou les icones Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f3e8; }
        .card-slot {
            width: 100%;
            height: 60px;
            background-color: #e5e7eb;
            border: 2px dashed #9ca3af;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 700;
            border-radius: 8px;
            transition: all 0.2s;
            cursor: pointer;
            user-select: none;
        }
        .card-value {
            width: 90%;
            height: 90%;
            background-color: #ffffff;
            border: 3px solid #1f2937;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: #1f2937;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
        }
        .card-back {
            background-color: #4f46e5;
            border: 3px solid #fcd34d;
            color: white;
        }
        .card-slot:hover:not(.has-card, .not-playable) {
            background-color: #fca5a5;
            border-color: #ef4444;
        }
        .can-replace {
            box-shadow: 0 0 0 4px #10b981; /* Ring verd per a reemplaçar */
        }
        .can-replace:hover {
            transform: scale(1.02);
        }
        .current-player {
            box-shadow: 0 0 0 3px #f59e0b;
        }
        
        /* Estils per la carta-cursor */
        #floating-card {
            position: fixed;
            pointer-events: none; /* Important per permetre el clic sota el cursor */
            z-index: 1000;
            width: 50px;
            height: 70px;
            transform: translate(-50%, -50%); /* Centrar la carta sota el cursor */
            opacity: 0;
            transition: opacity 0.1s;
        }
        #floating-card.active {
            opacity: 1;
        }
        #floating-card .card-value {
            width: 100%;
            height: 100%;
            font-size: 1.5rem;
            line-height: 1;
        }
    </style>
</head>
<body class="p-4 sm:p-6">

    <!-- Carta flotant (substitut de cursor) -->
    <div id="floating-card">
        <div class="card-value shadow-2xl"></div>
    </div>
    
    <!-- UI DEL JOC -->
    <div class="max-w-4xl mx-auto p-4 bg-white rounded-xl shadow-2xl">
        
        <!-- Header i Estat -->
        <header class="mb-4 flex flex-col sm:flex-row justify-between items-center pb-4 border-b">
            <h1 class="text-3xl font-extrabold text-gray-900 mb-2 sm:mb-0">Rack-O <span class="text-indigo-600 text-base">v. Multiplayer</span></h1>
            <div id="game-status" class="text-sm font-semibold">Carregant...</div>
        </header>

        <!-- DEBUG & DIAGNÒSTIC (Ajudar a l'usuari a comprovar la connexió) -->
        <div class="text-xs p-2 mb-4 bg-yellow-50 rounded-lg border border-yellow-200">
            <h4 class="font-bold text-yellow-800 mb-1">Panell de Diagnòstic (Debug)</h4>
            <span id="user-id-display" class="block text-gray-600">ID d'Usuari: <span class="font-mono text-xs">Carregant...</span></span>
            <span id="game-id-display" class="block text-gray-600">ID de Partida Activa: <span id="game-id-value" class="font-bold text-red-600">N/A</span></span>
        </div>
        <!-- Fi de DEBUG & DIAGNÒSTIC -->

        <!-- Àrea Principal de l'Aplicació (Lobby o Joc) -->
        <div id="main-container">
            <div id="game-container" class="mt-4">
                <!-- El contingut del lobby o joc es renderitzarà aquí -->
                <p class="text-center text-gray-600">Carregant l'estat de la partida...</p>
            </div>
            
            <!-- Àrea de Joc Activa -->
            <div id="game-active-area" class="mt-6 hidden">

                <!-- Zones de Munt i Descart -->
                <div class="flex justify-center space-x-8 mb-6 p-4 bg-gray-50 rounded-lg shadow-inner">
                    
                    <div class="flex flex-col items-center">
                        <h4 class="font-bold text-gray-700 mb-2 flex items-center">
                            <i data-lucide="layers" class="w-4 h-4 mr-1"></i> Munt (<span id="draw-pile-count">0</span>)
                        </h4>
                        <div id="draw-pile" class="w-20 h-32 border-4 border-gray-400 rounded-lg cursor-pointer hover:border-indigo-600 transition duration-200">
                            <!-- Carta coberta -->
                        </div>
                    </div>
                    
                    <div class="flex flex-col items-center">
                        <h4 class="font-bold text-gray-700 mb-2 flex items-center">
                            <i data-lucide="trash-2" class="w-4 h-4 mr-1"></i> Descarts
                        </h4>
                        <div id="discard-pile" class="w-20 h-32 border-4 border-gray-400 rounded-lg cursor-pointer hover:border-green-600 transition duration-200">
                            <!-- Carta visible -->
                        </div>
                    </div>

                </div>
                
                <!-- Missatge/Acció de Torn -->
                <div id="action-area" class="mb-6 p-3 rounded-xl text-center">
                    <!-- Botó de 'Començar Partida' o missatge de torn -->
                </div>

                <!-- El teu Atril (Rack) -->
                <div class="bg-indigo-50 p-4 rounded-xl shadow-inner mb-6">
                    <h3 class="text-xl font-bold text-indigo-700 mb-3">El Teu Atril (Rack)</h3>
                    <div id="my-rack" class="grid grid-cols-2 sm:grid-cols-5 gap-3">
                        <!-- Les 10 ranures de l'atril es renderitzaran aquí -->
                    </div>
                </div>

                <!-- Puntuacions i Altres Jugadors -->
                <h3 class="text-xl font-bold text-gray-700 mb-3">Puntuació Global</h3>
                <div id="all-players-score" class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                    <!-- Puntuacions de tots els jugadors -->
                </div>

            </div>
        </div>
    </div>

    <!-- Modal Personalitzat (substitut d'alert/confirm) -->
    <div id="custom-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 transition-opacity duration-300">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h4 id="modal-title" class="text-2xl font-bold mb-3 text-red-600">Títol del Modal</h4>
            <p id="modal-message" class="text-gray-700 mb-4">Missatge del modal.</p>
            <button onclick="window.gameFunctions.closeModal()" class="w-full py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-700">
                Entès
            </button>
        </div>
    </div>

    <!-- Firebase SDKs - MOGUT AL FINAL DEL BODY PER GARANTIR QUE ELS ELEMENTS HTML ES CARREGUIN ABANS -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, updateDoc, arrayRemove, arrayUnion, runTransaction, getDocs, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        /** * ===============================================================================
         * Configuració Manual de Firebase per a Execució Fora de Canvas (com GitHub Pages)
         * ===============================================================================
         * Quan utilitzis aquest codi fora de l'entorn Canvas (p. ex., GitHub Pages), 
         * NECESSITES substituir l'objecte FIREBASE_SETTINGS a continuació per la teva
         * configuració real de Firebase. AQUESTA CONFIGURACIÓ HA ESTAT AFEGIDA PER L'USUARI.
         */
        const FIREBASE_SETTINGS = { 
            apiKey: "AIzaSyDQWCvBru356guXE3tAB6R2VjOsqaFHttY",
            authDomain: "rack-o-16931.firebaseapp.com",
            projectId: "rack-o-16931",
            storageBucket: "rack-o-16931.firebasestorage.app",
            messagingSenderId: "127219641303",
            appId: "1:127219641303:web:285e63d0bfecb9da4db992",
            measurementId: "G-1EQ8RBNL1J"
        }; 
        const MANUAL_APP_ID_FOR_PATH = "rack-o-16931"; // Utilitza Project ID com a fallback per la ruta /artifacts/{appId}/public/...


        // Configuració de Firebase i variables globals (Prioritza Canvas, sinó usa MANUAL)
        const isCanvasEnvironment = typeof __firebase_config !== 'undefined';
        
        const appId = isCanvasEnvironment ? (typeof __app_id !== 'undefined' ? __app_id : 'default-app-id') : MANUAL_APP_ID_FOR_PATH;
        
        const firebaseConfig = isCanvasEnvironment ? 
            JSON.parse(__firebase_config) : 
            FIREBASE_SETTINGS;
            
        const initialAuthToken = isCanvasEnvironment ? (typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null) : null;

        let app, db, auth;
        let userId = null;
        let gameId = null;
        let gameState = null;
        let unsubscribeGame = null;

        // Estats de joc del client
        let heldCard = null; 
        let heldSource = null; 
        
        // Referència al component de la carta flotant (cursor)
        const floatingCardElement = document.getElementById('floating-card');
        const floatingCardValueElement = floatingCardElement.querySelector('.card-value');

        // Escolta el moviment del ratolí per la carta flotant
        document.addEventListener('mousemove', (e) => {
            if (heldCard) {
                floatingCardElement.style.left = `${e.clientX}px`;
                floatingCardElement.style.top = `${e.clientY}px`;
            }
        });


        // Funció per generar un ID de 4 dígits (1000-9999)
        const generate4DigitId = () => {
            return String(Math.floor(1000 + Math.random() * 9000));
        };


        // Inicialització de Firebase
        const initFirebase = async () => {
            if (Object.keys(firebaseConfig).length === 0 && !isCanvasEnvironment) {
                console.error("Firebase config is missing. Please set FIREBASE_SETTINGS for GitHub execution.");
                document.getElementById('main-container').innerHTML = `<p class="text-red-600">Error: La configuració de Firebase no està disponible. Si ho executes des de GitHub, has d'establir la variable FIREBASE_SETTINGS al codi font amb la teva clau.</p>`;
                return;
            }
            try {
                // setLogLevel('debug'); // Uncomment to see detailed Firestore logs
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Authentication
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        // UPDATE DEBUG PANEL: Show User ID
                        document.getElementById('user-id-display').innerHTML = `ID d'Usuari: <span class="font-mono text-xs">${userId}</span>`;
                        console.log(`[AUTH] User ID set: ${userId}. Attempting to load last game...`);
                        loadLastGame();
                    } else {
                        // Lògica d'autenticació adaptada per a Canvas vs GitHub
                        if (isCanvasEnvironment && initialAuthToken) {
                            // Entorn Canvas: Usa el token personalitzat
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            // Entorn GitHub/Altres: Usa l'autenticació anònima
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Error inicialitzant Firebase:", error);
                document.getElementById('main-container').innerHTML = `<p class="text-red-600">Error en la inicialització de l'aplicació. (Comprova la configuració de FIREBASE_SETTINGS si no ets a Canvas).</p>`;
            }
        };

        // --- FUNCIONS CORE DE JOC ---
        // Funció per crear i barrejar la baralla
        const createAndShuffleDeck = (maxCard) => {
            let newDeck = Array.from({ length: maxCard }, (_, i) => i + 1);
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        };

        // Condició 1: Comprovar si totes les cartes estan en ordre ascendent
        const checkAscendingOrder = (rack) => {
            const NUM_CARDS_IN_RACK = 10;
            if (rack.length !== NUM_CARDS_IN_RACK || rack.includes(null)) return false;
            for (let i = 0; i < rack.length - 1; i++) {
                if (rack[i] >= rack[i + 1]) {
                    return false;
                }
            }
            return true;
        };

        // Condició 2 (Només 2 Jugadors): Comprovar si hi ha 3 números consecutius
        const checkForConsecutiveSequence = (rack) => {
            for (let i = 0; i <= rack.length - 3; i++) {
                if (rack[i] + 1 === rack[i + 1] && rack[i + 1] + 1 === rack[i + 2]) {
                    return true; 
                }
            }
            return false;
        };

        // Comprovació de la Condició de Victòria Final
        const checkVictoryCondition = (game, playerRack) => {
            const isAscending = checkAscendingOrder(playerRack);
            if (!isAscending) return false;
            if (game.numPlayers > 2) {
                return true;
            }
            if (game.numPlayers === 2) {
                return checkForConsecutiveSequence(playerRack);
            }
            return false; 
        };

        // Funció per calcular la puntuació de Rack-O (Seqüència ascendent des de la ranura #1)
        const calculateSequenceScore = (rack) => {
            const SEQUENCE_POINTS_PER_CARD = 5;
            const NUM_CARDS_IN_RACK = 10;
            let score = 0;
            if (rack.length !== NUM_CARDS_IN_RACK || rack.includes(null)) return 0;
            
            for (let i = 0; i < rack.length; i++) {
                if (i === 0 || rack[i] > rack[i - 1]) {
                    score += SEQUENCE_POINTS_PER_CARD;
                } else {
                    break;
                }
            }
            return score;
        };
        // --- FI DE FUNCIONS CORE DE JOC ---


        // --- FIREBASE I GESTIÓ DE PARTIDES ---
        const CARD_DECK_SIZES = { 2: 40, 3: 50, 4: 60 };
        const NUM_CARDS_IN_RACK = 10;
        const RACKO_POINTS = 75;

        const getGameRef = (gameId) => doc(db, 'artifacts', appId, 'public', 'data', 'racko_games', gameId);

        const loadLastGame = async () => {
            if (!userId || gameId) return; 

            // Search for an active game where the user is a participant
            const q = query(
                collection(db, 'artifacts', appId, 'public', 'data', 'racko_games'),
                where('playerIds', 'array-contains', userId) // Check if user is in playerIds array
            );
            
            try {
                const snapshot = await getDocs(q);
                if (!snapshot.empty) {
                    // Found an existing game!
                    gameId = snapshot.docs[0].id;
                    console.log(`[LOAD] Reconnecting to existing game ID: ${gameId}`);
                    startListeningToGame(gameId);
                } else {
                    console.log("[LOAD] No active game found for this user. Rendering lobby.");
                    renderLobby();
                }
            } catch (error) {
                console.error("Error carregant l'última partida (REQUEREIX REVISIÓ DE REGLES):", error);
                renderLobby("Error carregant l'última partida. (Problema de Permisos/Connexió). Intenta crear-ne una de nova.");
            }
        };

        const startListeningToGame = (id) => {
            if (unsubscribeGame) unsubscribeGame();
            gameId = id;
            document.getElementById('game-id-value').textContent = gameId; // Update debug panel immediately

            unsubscribeGame = onSnapshot(getGameRef(gameId), (doc) => {
                if (doc.exists()) {
                    gameState = doc.data();
                    console.log(`[SNAPSHOT] Game state updated for ID: ${gameId}, Status: ${gameState.status}`);
                    renderGame(gameState);
                } else {
                    console.error(`[SNAPSHOT ERROR] Partida ${gameId} ja no existeix. Tornant al Lobby.`);
                    // Case 1: Game document was deleted (e.g., by another player or server cleanup)
                    resetLobbyState("La partida ha estat eliminada del servidor (Firestore). Torna a crear o unir-te.");
                }
            }, (error) => {
                console.error("Error en onSnapshot (connexió perduda):", error);
                // Case 2: Real-time connection error (e.g., network timeout, permission issue)
                resetLobbyState("Error de connexió en temps real. Torna a intentar d'unir-te. (Revisa la teva connexió)");
            });
        };

        // Nova funció per reiniciar l'estat local i forçar el renderitzat del Lobby
        const resetLobbyState = (message = "L'estat de connexió s'ha netejat. Torna a unir-te o crea una nova partida.") => {
            console.log("[LOBBY] Reiniciant estat local.");
            if (unsubscribeGame) {
                unsubscribeGame();
                unsubscribeGame = null;
            }
            gameId = null;
            gameState = null;
            heldCard = null;
            heldSource = null;
            floatingCardElement.classList.remove('active');
            document.getElementById('game-id-value').textContent = 'N/A'; // Clear debug panel
            renderLobby(message);
        };

        // PERSISTÈNCIA DEL NOM: Guarda el nom al localStorage
        const validatePlayerName = (name) => {
            const trimmedName = name.trim();
            if (trimmedName.length < 2 || trimmedName.length > 15) {
                showModal("Error de Nom", "Introdueix un nom vàlid d'entre 2 i 15 caràcters.");
                return null;
            }
            localStorage.setItem('racko_player_name', trimmedName); // Save on success
            return trimmedName;
        }

        const createGame = async (numPlayers, rawPlayerName) => {
            const createButton = event.currentTarget;
            const originalText = createButton.innerHTML;
            
            const playerName = validatePlayerName(rawPlayerName);
            if (!playerName || numPlayers < 2 || numPlayers > 4) return; // Validation failed
            
            // Set loading state *after* successful validation
            createButton.disabled = true;
            createButton.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 mr-2 animate-spin"></i> Creant...`;
            lucide.createIcons();
            
            let uniqueId = null;
            let maxRetries = 10;
            for (let i = 0; i < maxRetries; i++) {
                const potentialId = generate4DigitId();
                const gameRef = getGameRef(potentialId);
                const docSnap = await getDoc(gameRef);

                if (!docSnap.exists()) {
                    uniqueId = potentialId;
                    break;
                }
            }

            if (!uniqueId) {
                showModal("Error", "No s'ha pogut generar una ID única de 4 dígits. Torna a intentar-ho.");
                createButton.disabled = false;
                createButton.innerHTML = originalText;
                return;
            }

            const maxCardValue = CARD_DECK_SIZES[numPlayers];
            const fullDeck = createAndShuffleDeck(maxCardValue);
            
            const newPlayer = {
                id: userId,
                name: playerName, 
                rack: Array(NUM_CARDS_IN_RACK).fill(null), 
                score: 0,
                scoreHistory: []
            };

            const newGameData = {
                status: 'lobby',
                numPlayers: numPlayers,
                maxCardValue: maxCardValue,
                playerIds: [userId],
                players: [newPlayer],
                deck: fullDeck,
                discardPile: [],
                turn: null, 
                messages: [`${newPlayer.name} ha creat la partida.`],
                lastUpdate: Date.now()
            };

            try {
                const newGameRef = getGameRef(uniqueId);
                await setDoc(newGameRef, newGameData);
                console.log(`[CREATE] Partida ${uniqueId} creada amb èxit.`);
                // Start listening immediately upon creation success
                startListeningToGame(uniqueId);
            } catch (error) {
                console.error("Error creant la partida (REQUEREIX REVISIÓ DE REGLES):", error);
                showModal("Error", "No s'ha pogut crear la partida. Assegura't de tenir connexió a internet i que les regles de seguretat ho permetin.");
                resetLobbyState(); // Ensures lobby is re-rendered with error message
            } finally {
                // If resetLobbyState was NOT called (i.e., startListeningToGame succeeded), 
                // the UI will transition away from the lobby, so no need to reset button.
                if (!gameId) {
                     createButton.disabled = false;
                     createButton.innerHTML = originalText;
                }
            }
        };

        const joinGame = async (gameIdToJoin, rawPlayerName) => {
            const joinButton = document.getElementById('join-button');
            
            // 1. Initial validation
            const playerName = validatePlayerName(rawPlayerName);
            const trimmedId = gameIdToJoin.trim();
            if (!playerName) return; // Name error already handled by modal in validatePlayerName
            
            if (!trimmedId || trimmedId.length !== 4 || isNaN(trimmedId)) {
                showModal("Error", "Introdueix una ID de partida vàlida de 4 dígits.");
                return;
            }
            
            // Set loading state *after* successful validation
            joinButton.disabled = true;
            joinButton.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 mr-2 animate-spin"></i> Carregant...`;
            lucide.createIcons(); 

            const gameRef = getGameRef(trimmedId);

            try {
                console.log(`[JOIN] Attempting to join game ID: ${trimmedId}`);
                
                const gameDoc = await getDoc(gameRef);
                
                if (!gameDoc.exists()) {
                    console.error(`[JOIN ERROR] Game ID ${trimmedId} not found.`);
                    throw new Error("La partida no existeix (Codi incorrecte)."); 
                }

                const game = gameDoc.data();
                
                if (game.playerIds.includes(userId)) {
                    // Reconnection case: user already in the game
                    console.log(`[JOIN] User ${userId} already in game. Reconnecting.`);
                    startListeningToGame(trimmedId);
                    return; 
                }

                // Joining case: use transaction to add player
                await runTransaction(db, async (transaction) => {
                    const gameDocInTx = await transaction.get(gameRef);
                    const gameInTx = gameDocInTx.data(); 
                    
                    if (gameInTx.status !== 'lobby') {
                        throw new Error("La partida ja ha començat.");
                    }
                    if (gameInTx.playerIds.length >= gameInTx.numPlayers) {
                        throw new Error("La partida està plena.");
                    }
                    
                    const newPlayer = {
                        id: userId,
                        name: playerName, 
                        rack: Array(NUM_CARDS_IN_RACK).fill(null),
                        score: 0,
                        scoreHistory: []
                    };
                    
                    if (gameInTx.players.some(p => p.name.toLowerCase() === playerName.toLowerCase())) {
                        throw new Error("Aquest nom ja està en ús en aquesta partida.");
                    }

                    const updatedPlayers = [...gameInTx.players, newPlayer];

                    transaction.update(gameRef, {
                        playerIds: arrayUnion(userId),
                        players: updatedPlayers,
                        messages: arrayUnion(`${newPlayer.name} s'ha unit.`),
                        lastUpdate: Date.now()
                    });
                    console.log(`[JOIN SUCCESS] Transaction committed.`);

                });
                
                // If transaction succeeds, start listening
                startListeningToGame(trimmedId);

            } catch (error) {
                console.error("=================================================");
                console.error("[!!! REQUERIT PER AL DIAGNÒSTIC !!!] Error unint-se a la partida (REQUEREIX REVISIÓ DE REGLES):", error);
                console.error("=================================================");
                // Specific error messages for the user
                let msg = error.message.includes("document does not exist") ? "La partida no existeix (Codi incorrecte)." : error.message;
                // Check for generic Firebase permission error and provide a specific user message
                if (error.code === 'permission-denied' || error.message.includes('permissions')) {
                     msg = "Permisos Insuficients: Assegura't que has publicat les regles de seguretat més recents a Firebase!";
                }
                showModal("Error d'Unió", `No s'ha pogut unir a la partida: ${msg}.`);
                resetLobbyState(); // Ensure UI state is clean after failure
            } finally {
                // Ensure button resets if connection was NOT successful
                if (!gameId) { 
                    joinButton.disabled = false;
                    joinButton.innerHTML = `Unir-se`;
                }
            }
        };

        const startGame = async () => {
            if (!gameState || gameState.status !== 'lobby' || gameState.playerIds.length < 2) return;
            
            // Nova validació: Assegurar-se que el nombre de jugadors actuals coincideix amb la mida màxima de la partida
            if (gameState.players.length !== gameState.numPlayers) {
                 showModal("❌ Partida Incompleta", `Encara falten ${gameState.numPlayers - gameState.players.length} jugadors per unir-se a la partida de ${gameState.numPlayers}.`);
                 return;
            }

            try {
                await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);

                    if (!gameDoc.exists() || gameDoc.data().status !== 'lobby') {
                        throw new Error("Estat de partida invàlid o ja iniciada.");
                    }

                    const game = gameDoc.data();
                    let fullDeck = createAndShuffleDeck(game.maxCardValue); 
                    let players = game.players;

                    let newRacks = Array.from({ length: players.length }, () => Array(NUM_CARDS_IN_RACK).fill(null));

                    for (let i = NUM_CARDS_IN_RACK - 1; i >= 0; i--) { 
                        for (let j = 0; j < players.length; j++) {
                            const card = fullDeck.pop();
                            if (card !== undefined) {
                                newRacks[j][i] = card; 
                            }
                        }
                    }

                    players = players.map((p, index) => ({
                        ...p,
                        rack: newRacks[index]
                    }));

                    const firstDiscard = fullDeck.pop();
                    let discardPile = [];
                    if (firstDiscard !== undefined) {
                        discardPile.push(firstDiscard);
                    }
                    
                    const startingPlayerIndex = Math.floor(Math.random() * players.length);
                    const startingPlayerId = players[startingPlayerIndex].id;

                    transaction.update(gameRef, {
                        status: 'playing',
                        players: players, 
                        deck: fullDeck,
                        discardPile: discardPile,
                        turn: startingPlayerId,
                        messages: arrayUnion("La partida ha començat! Bona sort."),
                        lastUpdate: Date.now()
                    });
                    console.log(`[START GAME] Partida ${gameId} a 'playing'. Torn de ${startingPlayerId}.`);

                });
            } catch (error) {
                console.error("Error iniciant la partida:", error);
                showModal("Error", `No s'ha pogut iniciar la partida: ${error.message}`);
            }
        };

        const handleDrawCard = async (source) => {
            if (!isMyTurn() || heldCard) {
                if (!isMyTurn()) {
                    showModal("❌ Acció Invàlida", "No és el teu torn.");
                } else if (heldCard) {
                    showModal("❌ Acció Invàlida", "Ja tens una carta a la mà.");
                }
                return;
            }
            if (source === 'draw' && gameState.deck.length === 0) return showModal("❌ Baralla Buida", "No queden cartes al munt.");
            if (source === 'discard' && gameState.discardPile.length === 0) return showModal("❌ Descart Buida", "La pila de descarts està buida.");
            
            let cardValue = null;

            try {
                await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data();
                    
                    if (game.turn !== userId) throw new Error("Ja no és el teu torn.");

                    if (source === 'draw') {
                        cardValue = game.deck.pop(); 
                        if (cardValue === undefined) throw new Error("Baralla buida.");
                    } else if (source === 'discard') {
                        cardValue = game.discardPile.pop();
                         if (cardValue === undefined) throw new Error("Descart buit.");
                    }

                    const updateData = {};
                    if (source === 'draw') {
                        updateData.deck = game.deck; 
                    } else if (source === 'discard') {
                        updateData.discardPile = game.discardPile; 
                    }
                    
                    transaction.update(gameRef, updateData);
                });
                
                heldCard = cardValue;
                heldSource = source;
                renderRack(); 
                
                floatingCardValueElement.textContent = heldCard;
                floatingCardElement.classList.add('active');

                if (source === 'draw') {
                    console.log(`[DRAW] Carta ${cardValue} agafada del munt.`);
                    // The button will be shown in renderGame's action area update
                } else {
                    const messageElement = document.getElementById('action-area');
                    messageElement.innerHTML = `
                        <div class="p-2 border border-blue-200 rounded-lg bg-blue-50">
                            <p class="text-sm font-semibold text-blue-700">Has agafat la carta <span class="text-xl text-red-600 font-extrabold">${cardValue}</span> del descart. Clica una ranura per reemplaçar.</p>
                        </div>
                    `;
                    document.getElementById('discard-immediate-btn')?.classList.add('hidden');
                }


            } catch (error) {
                console.error("Error agafant la carta:", error);
                showModal("Error", `No s'ha pogut agafar la carta. Torna a intentar-ho: ${error.message}`);
            }
        };

        const handleDiscardImmediate = async () => {
            if (!isMyTurn() || !heldCard || heldSource !== 'draw') return showModal("❌ Acció Invàlida", "Només pots descartar immediatament si agafes del munt.");

            const cardToDiscard = heldCard;

            try {
                 await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data();

                    if (game.turn !== userId) throw new Error("Ja no és el teu torn.");

                    game.discardPile.push(cardToDiscard);

                    const nextTurnId = getNextPlayerId(game);

                    transaction.update(gameRef, {
                        discardPile: game.discardPile,
                        turn: nextTurnId,
                        messages: arrayUnion(`${getMyPlayer().name} ha descartat immediatament la carta ${cardToDiscard}.`),
                        lastUpdate: Date.now()
                    });
                });
                heldCard = null;
                heldSource = null;
                floatingCardElement.classList.remove('active'); 
                document.getElementById('discard-immediate-btn')?.classList.add('hidden');

            } catch (error) {
                console.error("Error descartant immediatament:", error);
                showModal("Error", "No s'ha pogut descartar immediatament la carta.");
            }
        };


        const handleReplaceCard = async (slotIndex) => {
            if (!isMyTurn() || !heldCard) return showModal("❌ Acció Invàlida", "Primer has d'agafar una carta.");
            
            const player = getMyPlayer();
            const cardToDiscard = player.rack[slotIndex];
            const newCard = heldCard;

            try {
                await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data();

                    if (game.turn !== userId) throw new Error("Ja no és el teu torn.");
                    
                    const players = game.players;
                    const currentPlayerIndex = players.findIndex(p => p.id === userId);
                    if (currentPlayerIndex === -1) throw new Error("Jugador no trobat a la transacció.");
                    
                    const currentPlayer = players[currentPlayerIndex];

                    const newRack = [...currentPlayer.rack];
                    newRack[slotIndex] = newCard;

                    let status = game.status;
                    let winnerId = null;
                    let winMessage = '';

                    if (checkVictoryCondition(game, newRack)) {
                        status = 'finished_hand';
                        winnerId = userId;
                        
                        if (game.numPlayers === 2) {
                            winMessage = `${currentPlayer.name} crida "Rack-O!" i guanya la mà complint la seqüència de 3!`;
                        } else {
                            winMessage = `${currentPlayer.name} crida "Rack-O!" i guanya la mà!`;
                        }
                        game.messages.push(winMessage);
                    }

                    currentPlayer.rack = newRack;
                    
                    game.discardPile.push(cardToDiscard);

                    const nextTurnId = (status !== 'finished_hand') ? getNextPlayerId(game) : game.turn;

                    transaction.update(gameRef, {
                        players: players,
                        discardPile: game.discardPile,
                        turn: nextTurnId,
                        status: status,
                        winnerId: winnerId || game.winnerId || null,
                        messages: arrayUnion(`${currentPlayer.name} ha reemplaçat la ranura ${slotIndex + 1} (${cardToDiscard}) per la carta ${newCard}.`),
                        lastUpdate: Date.now()
                    });
                });
                
                heldCard = null;
                heldSource = null;
                floatingCardElement.classList.remove('active'); 
                document.getElementById('discard-immediate-btn')?.classList.add('hidden');

            } catch (error) {
                console.error("Error reemplaçant la carta:", error);
                showModal("Error", "No s'ha pogut reemplaçar la carta. Torna a intentar-ho.");
            }
        };

        const getNextPlayerId = (game) => {
            const playerIds = game.playerIds;
            const currentIndex = playerIds.indexOf(game.turn);
            const nextIndex = (currentIndex + 1) % playerIds.length;
            return playerIds[nextIndex];
        };
        
        const endHandAndScore = async () => {
            if (!gameState || gameState.status !== 'finished_hand' || gameState.winnerId !== userId) return showModal("❌ Acció Invàlida", "Només el guanyador pot puntuar la mà.");

            try {
                 await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data();

                    if (game.status !== 'finished_hand') throw new Error("Estat de partida incorrecte.");

                    let players = game.players;
                    const winnerId = game.winnerId;
                    
                    const newScores = players.map(p => {
                        let score = 0;
                        if (p.id === winnerId) {
                            score = RACKO_POINTS; 
                        } else {
                            score = calculateSequenceScore(p.rack); 
                        }

                        const newTotalScore = p.score + score;
                        return {
                            ...p,
                            rack: Array(NUM_CARDS_IN_RACK).fill(null), 
                            score: newTotalScore,
                            scoreHistory: [...p.scoreHistory, score]
                        };
                    });

                    const gameWinner = newScores.find(p => p.score >= 500);

                    const maxCardValue = game.maxCardValue;
                    const fullDeck = createAndShuffleDeck(maxCardValue);
                    let deck = fullDeck;
                    const newDiscardPile = [];
                    const nextTurnId = game.winnerId; 

                    const playersForNextHand = newScores.map(p => {
                        const newRack = [];
                        for (let i = 0; i < NUM_CARDS_IN_RACK; i++) {
                            const card = deck.pop(); 
                            if (card !== undefined) {
                                newRack.push(card);
                            }
                        }
                        newRack.reverse(); 

                        return { ...p, rack: newRack };
                    });
                    
                    if (deck.length > 0) {
                        newDiscardPile.push(deck.pop());
                    }

                    transaction.update(gameRef, {
                        status: gameWinner ? 'finished' : 'playing',
                        players: playersForNextHand,
                        deck: deck,
                        discardPile: newDiscardPile,
                        turn: nextTurnId,
                        winnerId: gameWinner ? gameWinner.id : null,
                        messages: arrayUnion(`La mà ha acabat. Punts de ronda assignats. Comença la nova mà ${gameWinner ? '(FINALITZADA)' : ''}.`),
                        lastUpdate: Date.now()
                    });
                });
                
            } catch (error) {
                console.error("Error finalitzant la mà:", error);
                showModal("Error", "No s'ha pogut finalitzar i puntuar la mà.");
            }
        };

        // --- FUNCIONS AUXILIARS I RENDERITZAT ---

        const getMyPlayer = () => gameState?.players.find(p => p.id === userId);
        const isMyTurn = () => gameState?.turn === userId;

        const renderLobby = (message = "") => {
            // Assegurar-se que la carta flotant estigui desactivada
            heldCard = null;
            floatingCardElement.classList.remove('active');

            // If the user is somehow in a game state but renderLobby is called, don't proceed.
            if (gameId && gameState) {
                 console.warn("Attempted to render Lobby while connected to a game. Skipping.");
                 return;
            }
            
            // Càrrega del nom guardat
            const savedName = localStorage.getItem('racko_player_name') || '';

            document.getElementById('game-status').innerHTML = `<span class="text-xl font-bold text-gray-800">Sala d'Espera</span>`;
            document.getElementById('game-container').innerHTML = `
                <div class="p-6 bg-white rounded-xl shadow-lg w-full max-w-lg mx-auto">
                    
                    <h3 class="text-xl font-bold mb-4 text-indigo-600">El Teu Nom</h3>
                    <p class="mb-2 text-sm text-gray-700">Com vols que et vegin els altres jugadors (2-15 caràcters)?</p>
                    <input type="text" id="player-name-input" maxlength="15" placeholder="Escriu el teu nom de jugador" value="${savedName}" class="w-full p-3 border-2 border-indigo-300 rounded-lg mb-6 focus:ring-indigo-500 focus:border-indigo-500 text-center text-xl font-semibold">


                    <h3 class="text-2xl font-bold mb-4 text-indigo-600">Unir-se a Partida</h3>
                    <p class="mb-2 text-sm text-gray-700">Introdueix el codi numèric de <span class="font-bold">4 dígits</span> de la partida existent.</p>
                    <input type="text" id="join-game-input" maxlength="4" placeholder="Codi de 4 dígits (Ex: 1234)" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-indigo-500 focus:border-indigo-500 text-center text-xl font-mono tracking-widest">
                    <button id="join-button" onclick="window.gameFunctions.joinGame(document.getElementById('join-game-input').value, document.getElementById('player-name-input').value)" class="w-full py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 mb-8">
                        Unir-se
                    </button>


                    <h3 class="text-2xl font-bold mb-4 text-indigo-600">Crear Partida</h3>
                    <p class="mb-4 text-gray-700">Selecciona el nombre de jugadors per començar. Es generarà un codi de <span class="font-bold text-red-600">4 dígits</span>.</p>
                    <div class="flex justify-around space-x-4">
                        ${[2, 3, 4].map(n => `
                            <button onclick="window.gameFunctions.createGame(${n}, document.getElementById('player-name-input').value)" class="flex-1 py-3 px-4 bg-purple-500 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition duration-300">
                                ${n} Jugadors (Cartes 1-${CARD_DECK_SIZES[n]})
                            </button>
                        `).join('')}
                    </div>
                    <p class="mt-4 text-sm text-red-600 font-semibold">${message}</p>
                    
                    <!-- BOTÓ DE REINICIAR LOBBY -->
                    <div class="mt-6 border-t pt-4">
                        <button onclick="window.gameFunctions.resetLobbyState()" class="w-full py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg shadow-md hover:bg-gray-300 transition duration-300 flex items-center justify-center">
                            <i data-lucide="rotate-ccw" class="w-4 h-4 mr-2"></i> Reiniciar Connexió
                        </button>
                    </div>

                </div>
            `;
            // Assegura't que l'àrea de joc activa estigui oculta
            document.getElementById('game-active-area').classList.add('hidden');
            document.getElementById('custom-modal').classList.add('hidden'); 
            lucide.createIcons();
        };

        const renderGame = (game) => {
            const container = document.getElementById('game-container');
            const myPlayer = getMyPlayer();

            // 1. CRITICAL CHECK for Data Integrity and Synchronization
            
            // Check if user is known to the game (their ID is in the list)
            if (!game.playerIds.includes(userId)) {
                // If we are listening to a game but are not listed as a player, something is deeply wrong. Reset.
                if (gameId) resetLobbyState("Error de Sincronització: El teu ID no es troba a la llista de jugadors. S'ha restablert la connexió.");
                return;
            }

            // CRITICAL CHECK for Active Game State: If status is NOT lobby, the player object *must* exist.
            if (!myPlayer && game.status !== 'lobby') {
                // This indicates a critical data error (player object vanished mid-game). Aggressive reset needed.
                console.error(`[RENDER ERROR] CRITICAL: Player ${userId} not found in the game object while game is active (${game.status}).`);
                let errorMessage = `<p class="text-xl text-red-600 font-semibold">Error de sincronització crític. Partida activa (${game.status}) sense el teu objecte de jugador. Esborrant l'estat local.</p>`;
                container.innerHTML = errorMessage;
                if (gameId) resetLobbyState("Error crític: El teu objecte de jugador ha desaparegut en una partida activa. S'ha restablert la connexió.");
                return;
            }
            
            // 2. Handle Lobby State
            if (game.status === 'lobby') {
                document.getElementById('game-active-area').classList.add('hidden');
                document.getElementById('game-container').innerHTML = ''; 
                // We proceed even if myPlayer is null (race condition after joining) because renderLobbyContent 
                // is designed to render based on game.players/playerIds and we are expecting an update soon.
                renderLobbyContent(game);
                return;
            }
            
            // 3. Handle Active Game States (Playing, Finished Hand, Finished Game)
            
            // If we reach here, myPlayer is guaranteed not null, and status is active.
            document.getElementById('game-active-area').classList.remove('hidden');
            document.getElementById('game-container').innerHTML = '';
            
            // Set floating card state
            if (heldCard) {
                floatingCardValueElement.textContent = heldCard;
                floatingCardElement.classList.add('active');
            } else {
                floatingCardElement.classList.remove('active');
            }

            const isFinishedHand = game.status === 'finished_hand';
            const isFinishedGame = game.status === 'finished';
            const isCurrentTurn = isMyTurn() && !isFinishedHand && !isFinishedGame;

            // 1. Renderitzat de l'Estat de la Partida i Informació del Jugador (Status Bar)
            let statusText = '';
            let statusColor = '';
            if (isFinishedGame) {
                const finalWinner = game.players.find(p => p.id === game.winnerId);
                statusText = `🏆 JOC FINALITZAT! Guanyador: ${finalWinner?.name || 'Desconegut'} amb ${finalWinner?.score} punts.`;
                statusColor = 'bg-yellow-500 text-gray-900';
            } else if (isFinishedHand) {
                const winnerName = game.players.find(p => p.id === game.winnerId)?.name || 'Algú';
                statusText = `✅ MÀ GUANYADA! ${winnerName} ha fet Rack-O!`;
                statusColor = 'bg-green-500 text-white';
            } else { // Playing
                const turnPlayer = game.players.find(p => p.id === game.turn);
                statusText = `👉 Torn de: ${turnPlayer?.name || 'Desconegut'}`;
                statusColor = isCurrentTurn ? 'bg-green-600 text-white' : 'bg-red-600 text-white';
            }
            document.getElementById('game-status').innerHTML = `<span class="px-4 py-2 rounded-full font-bold ${statusColor} text-sm">${statusText}</span>`;


            // 2. Renderitzat del Tauler de Joc (Deck & Discard)
            const deckContent = game.deck.length > 0 ? `<div class="card-back flex items-center justify-center rounded-lg w-full h-full text-2xl" onclick="${isCurrentTurn && !heldCard ? 'window.gameFunctions.handleDrawCard(\'draw\')' : ''}">
                <i data-lucide="layers"></i>
            </div>` : `<div class="flex items-center justify-center w-full h-full text-lg text-gray-500">Buit</div>`;
            document.getElementById('draw-pile').innerHTML = deckContent;
            document.getElementById('draw-pile-count').textContent = game.deck.length;

            const discardCard = game.discardPile[game.discardPile.length - 1];
            const discardClickableClass = isCurrentTurn && !heldCard && discardCard !== undefined ? 'cursor-pointer hover:border-green-600' : 'cursor-default';
            const discardContent = discardCard !== undefined ? `<div class="card-value w-full h-full flex items-center justify-center text-4xl text-red-600" onclick="${isCurrentTurn && !heldCard ? 'window.gameFunctions.handleDrawCard(\'discard\')' : ''}">${discardCard}</div>` : `<div class="flex items-center justify-center w-full h-full text-lg text-gray-500">Buit</div>`;
            document.getElementById('discard-pile').innerHTML = discardContent;
            document.getElementById('discard-pile').className = `w-20 h-32 border-4 border-gray-400 rounded-lg transition duration-200 ${discardClickableClass}`;


            // 3. Botó d'acció/Estat del joc
            let actionHtml = '';
            
            if (isFinishedHand && game.winnerId === userId) {
                actionHtml = `<button onclick="window.gameFunctions.endHandAndScore()" class="w-full py-3 bg-yellow-500 text-gray-900 font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-300 flex items-center justify-center">
                    <i data-lucide="trophy" class="mr-2"></i> Puntuar i Començar Nova Mà
                </button>`;
            } else if (isFinishedHand) {
                const winnerName = game.players.find(p => p.id === game.winnerId)?.name;
                actionHtml = `<p class="text-green-700 font-semibold p-2">Esperant que el guanyador (${winnerName}) punti la mà.</p>`;
            } else if (isFinishedGame) {
                 actionHtml = `<button onclick="window.gameFunctions.resetLobbyState()" class="w-full py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 flex items-center justify-center">
                    <i data-lucide="refresh-cw" class="mr-2"></i> Tornar al Lobby
                </button>`;
            } else if (isCurrentTurn && heldCard) {
                 actionHtml = `
                    <div class="p-2 border border-blue-200 rounded-lg bg-blue-50">
                        <p class="text-sm font-semibold text-blue-700">Has agafat la carta <span class="text-xl text-red-600 font-extrabold">${heldCard}</span>. Clica una ranura per reemplaçar.</p>
                        <button id="discard-immediate-btn" onclick="window.gameFunctions.handleDiscardImmediate()" class="hidden w-full py-2 mt-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-300">
                            Descartar Immediatament (Només si has agafat del munt)
                        </button>
                    </div>
                 `;
            } else if (isCurrentTurn) {
                actionHtml = `<p class="text-lg font-bold text-green-700 p-2 border border-green-200 rounded-lg bg-green-100">
                    <i data-lucide="bell" class="w-5 h-5 inline mr-1 animate-pulse"></i> És el teu torn! Tria del munt o del descart.
                </p>`;
            } else {
                const turnPlayerName = game.players.find(p => p.id === game.turn)?.name || 'Algú';
                actionHtml = `<p class="text-lg font-bold text-orange-700 p-2 border border-orange-200 rounded-lg bg-orange-50">
                    <i data-lucide="loader-2" class="w-5 h-5 inline mr-1 animate-spin"></i> Esperant el torn de ${turnPlayerName}...
                </p>`;
            }
            document.getElementById('action-area').innerHTML = actionHtml;
            
            // 4. Renderitzat de l'Atril (Rack)
            renderRack();

            // 5. Renderitzat de les Puntuacions Global
            document.getElementById('all-players-score').innerHTML = game.players
                .map(p => {
                    const isLocalPlayer = p.id === userId;
                    const isPlayerTurn = p.id === game.turn;
                    const cardClasses = isLocalPlayer ? 'bg-indigo-100 border-indigo-500' : 'bg-gray-100 border-gray-300';
                    const turnRing = isPlayerTurn ? 'ring-4 ring-yellow-500' : '';

                    return `
                        <div class="p-3 rounded-xl border-2 shadow-sm ${cardClasses} ${turnRing} transition duration-300">
                            <p class="font-bold text-lg flex items-center">
                                ${p.name} ${isLocalPlayer ? ' (Tu)' : ''}
                                ${isPlayerTurn ? '<i data-lucide="star" class="w-4 h-4 ml-2 text-yellow-600 fill-yellow-400"></i>' : ''}
                            </p>
                            <p class="text-sm text-gray-800 font-semibold">Puntuació Total: <span class="text-xl text-indigo-700">${p.score}</span></p>
                            <p class="text-xs text-gray-500">Última Puntuació: +${p.scoreHistory[p.scoreHistory.length - 1] || 0}</p>
                        </div>
                    `;
                }).join('');

            // 6. Actualitzar botó de descart immediat si l'estat local ho requereix
            if (isCurrentTurn && heldCard && heldSource === 'draw' && game.status === 'playing') {
                document.getElementById('discard-immediate-btn')?.classList.remove('hidden');
            }

            // 7. Actualitzar icones (després de canviar el DOM)
            lucide.createIcons();
        };

        // Funció per a renderitzar el contingut del Lobby (separada de renderGame)
        const renderLobbyContent = (game) => {
            const container = document.getElementById('game-container');
            const myPlayer = getMyPlayer();
            
            // Check if myPlayer is null (race condition or critical error)
            // If myPlayer is null, we assume the user's ID is correct but the object is pending sync.
            // We use the first player as the creator, as the current user might not be in the list yet.
            const creator = game.players[0];
            const isCreator = myPlayer ? myPlayer.id === creator.id : false;
            
            let playerListHtml = game.players.map(p => `<span class="font-semibold ${p.id === userId ? 'text-indigo-600' : 'text-gray-800'}">${p.name} ${p.id === creator.id ? '(Creador)' : ''}</span>`).join(', ');

            // Comprovació de la validació completa per al botó d'inici
            const isLobbyFull = game.players.length === game.numPlayers;
            
            let actionHtml = `<div class="p-6 bg-white rounded-xl shadow-lg w-full max-w-lg mx-auto border-t-4 border-blue-500">
                <p class="text-xl font-bold mb-4 text-blue-700">Esperant a la Sala d'Espera</p>
                <p class="text-lg font-bold text-gray-800 mb-2">Codi de Partida (4 Dígits) per Compartir: <span class="text-3xl font-extrabold select-all text-red-600 bg-red-100 p-1 rounded">${gameId}</span></p>
                <p class="text-sm text-gray-700">Jugadors connectats: ${game.players.length} de ${game.numPlayers}.</p>
                <p class="text-sm text-gray-700 mt-2">Jugadors: ${playerListHtml}</p>
                ${isLobbyFull ? 
                    `<p class="text-sm text-green-700 mt-2 font-bold">Lobby complet (${game.numPlayers}/${game.numPlayers}).</p>` : 
                    `<p class="text-sm text-gray-700 mt-2">Esperant ${game.numPlayers - game.players.length} jugadors més per unir-se...</p>`
                }
                ${isCreator && isLobbyFull ? `
                    <button onclick="window.gameFunctions.startGame()" class="w-full py-3 mt-4 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-300 flex items-center justify-center">
                        <i data-lucide="play" class="mr-2"></i> Iniciar Partida
                    </button>
                ` : isCreator ? `
                    <p class="mt-4 text-center text-red-600 font-semibold">Esperant que tots els jugadors (${game.numPlayers}) s'uneixin per iniciar la partida.</p>
                ` : `<p class="mt-4 text-center text-gray-600">Esperant que el creador de la partida (${creator.name}) l'iniciï quan estigui completa.</p>`}
            </div>`;
            
            container.innerHTML = actionHtml; 
            lucide.createIcons();
        };

        const renderRack = () => {
            if (!gameState) return;
            const myPlayer = getMyPlayer();
            // Aquesta funció només es crida des d'un estat actiu, on myPlayer és garantit (vegeu renderGame)
            if (!myPlayer) return; 

            const rackElement = document.getElementById('my-rack');
            const isCurrentTurn = isMyTurn() && gameState.status === 'playing';
            
            rackElement.innerHTML = myPlayer.rack.map((card, index) => {
                const isPlayableSlot = isCurrentTurn && heldCard && card !== null && gameState.status === 'playing';
                let cardHtml;
                const slotNumber = index + 1; 

                if (card === null) {
                    cardHtml = `<div class="card-slot not-playable">
                        ${slotNumber}
                    </div>`;
                } else {
                    cardHtml = `<div class="card-slot has-card ${isPlayableSlot ? 'can-replace' : ''} transition-all duration-300" 
                                onclick="${isPlayableSlot ? `window.gameFunctions.handleReplaceCard(${index})` : ''}">
                        <div class="card-value text-3xl">${card}</div>
                    </div>`;
                }

                return `
                    <div class="flex items-center space-x-2">
                        <span class="text-sm font-bold text-gray-800 w-6 text-right">${slotNumber}:</span>
                        <div class="flex-1">
                            ${cardHtml}
                        </div>
                    </div>
                `;
            }).join('');
        };

        const showModal = (title, message) => {
            const modal = document.getElementById('custom-modal');
            document.getElementById('modal-title').innerHTML = title;
            document.getElementById('modal-message').innerHTML = message;
            modal.classList.remove('hidden');
        };

        const closeModal = () => {
            document.getElementById('custom-modal').classList.add('hidden');
        };

        // Exportar funcions de joc a la finestra per a l'HTML
        window.gameFunctions = {
            createGame: (num, name) => createGame(num, name),
            joinGame: (id, name) => joinGame(id, name),
            startGame,
            handleDrawCard,
            handleReplaceCard,
            handleDiscardImmediate,
            endHandAndScore,
            resetLobbyState: () => resetLobbyState(), // Export without message for UI button
            closeModal
        };

        // Inici de l'aplicació
        initFirebase();
    </script>
</body>
</html>
